\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx, graphics, float}
\usepackage[a4paper, total={6in, 10in}]{geometry}
\title{DSD Memoria Práctica 3}
\author{Andrés Merlo Trujillo}
\date{}
\begin{document}

\maketitle

\section{Ejemplos}
En esta primera parte se pide copiar los códigos de prueba que aparecen en el guión de prácticas y comentar como funcionan y qué hacen.

Lo primero que hay que hacer es tener instalado una versión de OpenJDK lo suficientemente antigua ya que si no al usar el comando \textit{javac *.java} saldrá un error similar a este:

%INSERTAR ERROR DE COMPILACIÓN

En mi caso tenía la versión 18 de JDK y he tenido que descargarme la versión 11 de la misma y configurarla para que sea la que sale por defecto.

Algo notable que me ha ocurrido, no sé si ha sido mucha casualidad pero he probado la ejecución varias veces, es que estaba usando la versión de JDK 8 y en la primera parte del ejemplo 2 se daba bien la ejecución de las hebras sin haber entrelazamientos. Como me extrañaba, probé la última versión que tenía disponible mi distribución antes de dar error de compilación, que en este caso es la versión 11 como he dicho anteriormente. Con la versión 11 si se producen entrelazamientos, por lo que supongo que es problema de la versión.

Otro problema que he tenido esa la hora de usar el script, ya que dentro del mismo se lanzan secuencialmente el servidor y los clientes, esto produce que se lancen nada más que el servidor y que los clientes no se lancen.

%FOTO DE LO OCURRIDO
Para ello he separado la parte de la invocación de los clientes en otro script para poder lanzar ambos en dos terminales distintas.

\subsection{Ejemplo 1}
\subsubsection{Descripción}
Este ejemplo lo único que realiza es que el cliente posee un identificador pasado como argumento en la ejecución del cliente y este a su vez se lo pasa al servidor a través del propio método remoto.

En el lado del servidor al ejecutar el método hay dos opciones, si el identificador pasado acaba en 0 entonces duerme durante 5000ms (5 segundos), en otro caso simplemente indica que ha recibido la petición e indica el número de hebra.

%FOTO DEL ENTRELAZAMIENTO


\subsubsection{Implementación}
Para la implementación de este sistema primero es necesario realizar la interfaz del servidor que va a exportar los métodos a los clientes. En este caso sólo se exporta el método \textit{escribir\_mensaje}. También cabe destacar que debe heredar de \textit{Remote}.

En la parte del servidor se crea una clase que implementa los métodos de la interfaz ``Ejemplo\_I''.

El método imprime por la pantalla del servidor que ha recibido la petición del proceso. Además comprueba si el número de proceso es 0, en caso afirmativo se manda el servidor a dormir durante 5 segundos y luego, con independencia de que sea el proceso 0 ó no, se indica la el número del proceso.
\\
%HACE FALTA COMPROBAR QUE CREO QUE RMI ES MULTIHEBRA

\textbf{IMPORTANTE CAMBIAR TODO EL TEXTO QUE HE SUPUESTO QUE ES MULTIHEBRA Y NO LO ES}
\\\\
%COMPROBAR ESTO ULTIMO CON EL PDF
Luego en la parte del main del servidor activa el gestor de seguridad, que es exactamente igual para el cliente, crea una instancia de sí mismo (ya que el main se encuentra en la misma clase) y le indica al rmiregistry su dirección para que los clientes puedan encontrarlo...???

En la parte del cliente lo que hace es activar el gestor de seguridad, si no tenía uno ya, accede al \textit{rmiregistry} que se encuentra en la dirección pasada por consola, y finalmente obtiene a partir del registro la instancia para poder lanzar el método anteriormente mencionado.


\subsubsection{Funcionamiento}
El diagrama del sistema (sin incluir rmiregistry ni stubs, solo los propios objetos y clases) es el siguiente:
%INSERTAR DIAGRAMA QUE EXPLIQUE MAS O MENOS COMO FUNCIONA

Y ejemplos de ejecución son los siguientes:



\subsection{Ejemplo 2}
\subsubsection{Descripción}
En este ejemplo se realiza algo similar al anterior, pero esta vez el cliente lanza un numero de hebras que se pasan por consola. La lógica del servidor es exactamente igual al ejemplo anterior (y la del cliente también, pero es con hebras).

Un entrelazamiento que ocurre es que las hebras no realizan las peticiones de manera ordenada al servidor; es decir, en la impresión que realiza el servidor por consola se puede observar que no siguen un orden ascendente los clientes.

Tras varias ejecuciones se puede observar como se produce un entrelazamiento de mensajes en el servidor en el que se muestra que entran varias hebras a la vez y luego se muestran varias veces también que ya salen, al contrario que pasaba en el ejemplo 1 que mostraba el mensaje de entrada y luego el siguiente era el de salida, todo esto por ser un sólo cliente y monohebrado.

%MOSTRAR IMAGEN DEL ENTRELAZAMIENTO

Por tanto lo que está pasando es que varias hebras pueden invocar el método muy cerca una de otra y hacer que el servidor escriba dos mensajes de entrada antes de que pueda acabar el primero de los métodos para que imprima el mensaje de salida.

\subsubsection{Implementación}
La implementación de la parte del servidor es exactamente igual que en el ejemplo 1, salvo por algún ligero cambio del mensaje que se muestra por pantalla.


%ESTA ULTIMA PARTE ES NECESARIA COMPROBARLA
En la parte del cliente se realiza prácticamente lo mismo pero se encapsula en el método \textit{run} ya que son hebras, luego desde el main se crea un array de hebras y se lanzan con \textit{start}.

\subsubsection{Uso de \textit{synchronized}}
Cuando se usa sync es como si fuera un entorno monohebrado, solo puede entrar un trabajo al servidory hasta que este no se realice no continua.

Esto se puede ver porque cuando llega a una hebra que acaba en 0 para la ejecución para dormir 5 segundos.

%INSERTAR IMAGEN DE ESO
\subsection{Ejemplo 3}

\subsection{Diferencias entre los ejemplos}
\end{document}