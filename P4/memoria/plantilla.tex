\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx, graphics, float, hyperref}
\usepackage{listings}
\usepackage[a4paper, total={6in, 10in}]{geometry}

\title{DSD Memoria Práctica 4}
\author{Andrés Merlo Trujillo}
\date{}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
}

\begin{document}
%TODO: COMPROBAR EN LA PARTE DE SOCKET IO QUE PARTES SON EXACTAMENTE SOCKETS.
%TODO 2: MEJORAR LA EXPLICACIONES EN GENERAL, SOBRE TODO LA PARTE DE LOS SOCKETS QUE ESTA MUY RARA.

\maketitle

\tableofcontents

\newpage

\section{Introducción}
En esta práctica se pide implementar un ... \textbf{IMPORTANTE PONER AQUI LO QUE SE PIDE}.

Para ello, es necesario tener instalado Node.js y MongoDB. También es necesario instalar npm para poder instalar los módulos de Socket.io y el de MongoDB (driver para la conexion con la BB.DD.).

Un problema que he tenido ha sido que no podía ejecutar el archivo de prueba \textit{mongo-test.js}. Mostraba el mensaje de que el servidor se había iniciado, pero al intentar acceder con la URL ponía que la conexión había sido rechazada. Tras pasar un periodo de tiempo de unos 40 segundos, el programa mostraba un mensaje de error.

%MOSTRAR MENSAJE DE ERROR

Tras depurar el programa en busca del mensaje de error, me di cuenta que localhost se resolvía a \textit{::1}, que es la versión IPv6. Además al hacer ping a localhost obtenía lo siguiente:

%MOSTRAR PING CON IPV6

Por tanto siempre se estaba resolviendo a la dirección IPv6.

MongoDB por defecto no usa IPv6, por lo que hay dos opciones para que funcione:

\begin{itemize}
    \item Permitir a MongoDB que use también las direcciones IPv6 o.
    
    \item Modificar el archivo \textit{/etc/hosts} para que use otro nombre distinto.
\end{itemize}

AL final opté por la segunda opción. Para ello llamé a ``localhost'' en IPv6 como ``localhost6''. Ahora al hacer ping sí se obtiene la dirección loopback de IPv4:

%MOSTRAR FOTO DEL PING CORRECTO

%QUIZAS SI DA MAS FALLOS MONGO PONERLOS

\section{Primera parte. Ejemplos}
\subsection{helloworld.js}
\subsubsection{Descripción}
Este ejemplo lo único que realiza es mostrar por pantalla en el navegador el mensaje ``Hola mundo''.

Adicionalmente, también muestra por la terminal del servidor el \textbf{JSON COMPROBAR ESTO SEGURAMENTE ESTE MAL} con toda la información de la petición del cliente (navegador).

%MOSTRAR FOTOS TANTO DEL CLIENTE COMO DEL SERVIDOR

\subsubsection{Implementación}
Para realizar esto, lo primero que hay que hacer es montar el servidor HTTP. Para ello, se importa el módulo de Node.js ``http''.

Una vez importado, se crea el servidor con el método ``createServer'' cuyo argumento es una función que se ejecuta cada vez que se realiza una petición HTTP.

Dentro del cuerpo de esta función, para que el servidor muestre la información de la petición, es necesario usar ``request.headers'' y pasarlo al log de la consola de JavaScript.

Para que el cliente reciba el mensaje, es necesario escribir una cabecera básica con el código 200, indicando que es correcto y el tipo MIME, que en este caso será texto plano.

Luego con el método write, se escribe el mensaje ``Hola mundo'' en la página. POr último, se finaliza con end para que se mande el mesanje. %IMPORTANTE COMPROBAR ESTO, SEGURAMENTE ESTE MAL

%MOSTRAR FOTO DE LA PETICION GET QUE SE REALIZA

\subsection{calculadora.js}
\subsubsection{Descripción}
Este ejemplo implementa una calculadora básica haciendo uso de Node.js. 

A la calculadora se le pasa el operador y los operandos en la URL en el navegador. En caso de ser incorrectos o no tener suficientes, muestra en el navegador un error.

Las operaciones que puede hacer son: sumar, restar, producto y dividir.

La sintaxis de la URL es la siguiente: \textbf{http://localhost:8080/$<$operador$>$/$<$operando-1$>$/$<$operando-2$>$}.


%MOSTRAR MENSAJE DE SALIDA.

\subsubsection{Implementación}
La parte de creación del servidor es exactamente igual que en la que se realiza en ``helloworld.js''.

Se ha creado una función ``calcular'' que permite realizar las funciones de la calculadora.

Tambień se usa el módulo ``url'' para obtener la URL que pasa el cliente. El objetivo es conseguir obtener los parámetros para pasarlos a la función y que realice la cuenta. Para ello, se usa ``url.parse'' con el ``request.url'' para obtener mas informacion de la URL y luego solo se escoge el campo ``pathname''. Esto hace que se obtenga la URI, por ejemplo, si se quiere hacer ``1+2'': ``/sumar/1/2''.

Cabe notar que, en este caso, la línea que hace esto es innecesaria, ya que se puede hacer un simple ``request.url'' y obtener la URI deseada.


Luego, se elimina el primer ``/'' para poder hacer luego split con el mismo delimitador para obtener un array con el operador el primero, y los operadores al final.

A continuación, se pasa a float y se llama a la funcion ``calcular''.

Por último, se manda de manera idéntica a la explicada en la sección anterior para el ``helloworld.js''.


\subsection{calculadora-web.js}
PARTE DE OFRECER HTML
process.cwd() -> Ruta absoluta del path
fs -> parece como que ofrece la pagina html.

fs.reafile -> Lee la pagina html y la ofrece como en los ejemplos anteriores, poniendo el mime al correcto y escribiendolo.

PARTE DE REALIZAR LA cuenta
js:
exactamente igual que antes

HTML:
Crea la URL con los datos y hace un get con esa info para que luego se pueda mostrar

\subsubsection{Descripción}
Este ejemplo implementa exactamente lo mismo que ``calculadora.js'', pero teniendo una interfaz web que simplifica la introducción de los valores.

Tmbien hace uso de Node.js y de los módulos adicionales ``path'' y ``fs'' para buscar el archivo HTML con la ruta absoluta y también para comprobar la existencia de archivos en el sistema y de leerlos para ofrecerlos en el cliente.

%MOSTRAR EJEMPLO


Además muestra por la pantalla donde se ejecuta la petición REST que se ha realizado, que sigue la misma sintaxis que el ejemplo anterior.

\subsubsection{Implementación}
La implementacion es muy similar al anterior, pero en este caso se usa el modulo de Node.js ``fs'' para poder realizar operaciones con archivos.

Lo primero que tiene que hacer es enviar la pagina al navegador. Para ello, se consigue la URI como antes, luego se comprueba que si el usuario solo ha puesto la direccion (en este caso localhost:8080), en caso afirmativo se pone que sirva el archivo HTML. A continuación, se le añade la ruta absoluta de ese archivo y, finalmente, con el método ``exists'' comprueba que existe, y en caso afirmativo, con el método ``readFile'' se carga el archivo HTML de una manera similar a como se hacía para los mensajes en los ejemplos anteriores.

Una vez cargada la página, el usuario puede insertar los operandos y el operador y, al darle a enviar se ejecuta la función ``enviar'' que lo que hace es convertir los valores introducidos en una cadena del tipo ``operador/operando1/operando2''. LUego, realiza una petición HTTP GET al servidor con esta cadena, la cual al pasar por el método ``exists'' va a devolver que no existe porque no es un archivo y va a ejecutar el mismo código que en el ejemplo de la calculadora anterior.

%MOSTAR IMAGENES DE EJEMPLOS DE EJECUCION

\subsection{connections.js}
HTML -> MOSTRAR INFORMACION MEDIANTE FUNCIONES JS. ESTAS FUNCIONES SE LLAMAN DESDE EVENTOS SOCKET.IO A LOS QUE ESTA SUSCRITO. io.connect(serviceURL) hace que se ejecute el codigo js de io.sockets.on...

JS -> 
on es para recibir
emit para enviar
\subsubsection{Descripción}
Este ejemplo hace uso del modulo Socket.io para poder actualizar todos los clientes de manera asíncrona y realizar una comunicación entre el cliente y el servidor para que todos tengan la información mas actualizada.

Cuando un cliente se conecta, este aparece en la pantalla del navegador con su direccion IP y el puerto usado. Además, si se abren mas pestañas se puede ver como aparece la direccion y puerto del nuevo cliente, y si nos vamos a la pestaña del primer cliente se puede ver que se actualiza también. Esto mismo pasa tambien para las desconexiones, cuando un cliente se desconecta los demás lo ven en su sesión.

En la pantalla del servidor aparecen los clientes conectados, las nuevsas conexiones y cuando un usuario se va a desconectar.

%MOSTRAR FOTO PARA 1 CLIENTE Y LUEGO PARA VARIOS

Además, cuando se desconecta el servicio, aparece un mensaje informandolo.

\subsubsection{Implementación}
Para implementar este ejemplo es necesario crear un ``httpServer'' como se ha hecho en los ejemplos anteriores, pero esta vez sólo cargando el fichero html.

También es necesario crear el objeto Socket.io e indicarle la funcionalidad y los eventos que debe escuchar en cuanto se conecte un cliente. En este caso lo que se hace primero es añadir el usuario al array, luego se emite a los demás suscritos el cambio y por último se configuran los eventos ``output-evt'' y ``disconnect'' para mostrar un mensaje por el navegador y para actualizar los clientes conectados respectivamente.

En el fichero HTML se conencta al socket del servidor y se configuran los eventos que va a suscrbirise. El evento ``connect'' se ejecuta en cuanto se conecta y le manda un evnto??? del tipo ``output-evt'' al servidor, el cual devuelve de vuelta ``Hola Cliente!'' y lo capta el cliente en ``output-evt'', que actualiza el mensaje de la página HTML.

Cuando un cliente se desconecta se ejecuta en el servidor el evento ``disconnect'', el cual elimina al cliente de la lista y manda a todos los clientes el evento ``all-connections'' para que actualicen ellos también la lista.

Por último, todos los clientes tienen el evento ``disconnect'', que permite que cuando el servidor se caiga por diversos motivos, cambie el mensaje de la página.

%INTRODUCIR FOTOS DE SALIDA CON VARIOS CLIENTES Y TODO ESO, JUNTO CON LAS DEL SERVIDOR

El diagrama de interacciones es el siguiente:

%MOSTRAR SI ME VEO CAPAZ EL DIAGRAMA DE INTERACCION.
\subsection{mongo-test.js}
\subsubsection{Descripción}
Este ejemplo muestra al cliente todas las conexiones a la base de datos NoSQL, mostrando en un JSON el identificador, la dirección IP donde se encuentra el cliente, el puerto y la hora UTC a la que se ha realizado la conexión.

Cuando se refresca la página o se abre una pestaña nueva del navegador, aparecen nuevas líneas de conexiones a la base de datos.


%Mostrar una foto de la salida
\subsubsection{Implementación}
La implementación del servidor HTTP es exactamente igual que en ejemplos anteriores, cuando se realiza una petición, el servidor envia la pagina HTML que se encarga de mostrar las conexiones.

En la parte de la base de datos, lo primero que se hace es conectarse, luego se crea una base de datos con nombre ``pruebaBaseDatos''.

A continuación, con Socket.io, se crean los eventos que tiene que escuchar y emitir: 

\begin{itemize}
    \item my-address: manda al cliente su dirección IP y puerto
    \item poner: Inserta los datos que el cliente manda en la base de datos.
    \item obtener: busca en la base de datos el registro dado por la dirección IP del cliente y se lo manda al mismo (el cliente).
    \item poner: Se encarga de insertar en la base de datos la informacion que ha enviado el cliente.
\end{itemize}

Para la parte del fichero HTML en el cliente, se realiza algo similar a ejemplos anteriores. Los eventos se encargan de insertar en la base de datos las nuevas conexiones y de actualizar la lista del cliente.

\subsection{Diferencias entre los ejemplos}
La principal diferencia entre los distintos ejemplos, es que en algunos se hace uso de un fichero HTML dedicado con javascript incrustado para el cliente, mientras que en otros tales como ``helloworld.js'' o ``calculadora.js'' solo incrustan el mensaje en una página básica.

Otra diferencia es que ``helloworld.js'', ``calculadora.js'' y ``calculadora-web.js'' sólo hacen uso de Node.js, y algunos módulos del mismo. Mientras que en ``connections.js'' y ``mongo-test.js'' hacen uso de Socket.io adicionalmete.

Por último, ``mongo-test.js'' hace uso de un módulo (driver) para conectarse a una base de datos NoSQL. Por tanto, este es el mas complejo de todos.
\section{Segunda parte.}
\subsection{Descripción}
\subsection{Implementación}
\end{document}
